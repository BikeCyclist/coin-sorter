/* Improved Auto Coin Sorter V7.52                  */
/* - Rounded corners on coin rack                   */
/* - Includes UYU Uruguayan Peso                    */
/*                                                  */
/* Improved Auto Coin Sorter V7.51                  */
/* - Test to check customizer's underscore handling */
/*                                                  */
/* Improved Auto Coin Sorter V7.5                   */
/* - Includes KRW South Korean Won                  */
/* - Includes MKD Macedonian Denar                  */
/* - Includes MYR Malaysian Ringgit                 */
/* - Includes NZD New Zealand Dollar                */
/*                                                  */
/* Version History                                  */
/*                                                  */
/* Improved Auto Coin Sorter V7.41                  */
/* - Customizer syntax error fixed                  */
/* - Coin - roll and "classic" slot versions        */
/* - Custom currency support re - introduced        */
/* - New contoured back                             */
/* - Front tube rack retaining edge                 */
/* - Basebox can be printed upright now             */
/* - Includes NIS Israeli New Shekel                */
/* - Includes NOK Norwegian Krone                   */
/* - Includes RON Romanian Leu                      */
/* - Includes TWD New Taiwan Dollar                 */
/* - Includes TRY Turkish Lira                      */
/* - Includes XPF CFP Franc                         */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Improved Auto Coin Sorter V7.3                   */
/* - Scale placement more accurate                  */
/* - Includes IDR Indonesian Rupiah                 */
/* - Includes INR Indian Rupee                      */
/* - Includes ISK Icelandic Krona                   */
/* - Includes MXN Mexican Peso                      */
/* - Includes SGD Singapore Dollar                  */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/* Improved Auto Coin Sorter V7.2                   */
/* - New internal logic for coin selection          */
/* - Includes ARS Argentine Peso                    */
/* - Includes AUD Australian Dollar                 */
/* - Includes BRL Brazilian Real                    */
/* - Includes CLP Chilean Peso                      */
/* - Includes CZK Czech Koruna                      */
/* - Includes DKK Danish Krone                      */
/* - Includes HKD Hong Kong Dollar                  */
/* - Includes HUF Hungarian Forint                  */
/* - Includes JPY Japanese Yen                      */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Improved Auto Coin Sorter V7.1                   */
/* - Includes GBP British Pound                     */
/* - Includes RUB Russian Ruble                     */
/* - Unused "other" option removed from selection   */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Improved Auto Coin Sorter V7                     */
/* https://www.thingiverse.com/thing:3467834        */
/* - Includes Features from Compact Version         */
/* - Coin roll support looks at more details        */
/* - Coin tube base chamfered (anti - elephant)     */
/* - Coin tube base bottom marked with index number */
/* - New style of base box backside pattern added   */
/* - Topboard tolerance added                       */
/* - Increased topboard rim height                  */
/* - Extra height for right end of vertical guard   */
/* - Support for "other coins" dropped              */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Improved Auto Coin Sorter V6                     */
/* - Interim version, never released                */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Improved Auto Coin Sorter V5                     */
/* https://www.thingiverse.com/thing:3421345        */
/* - Obsolete image decoration code removed         */
/* - Unused dovetail code removed                   */
/* - Unused box/tube emptier code removed           */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Remixed from                                     */
/*                                                  */
/* Compact Improved Auto Coin Sorter                */
/* https://www.thingiverse.com/thing:3338193        */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Customized Auto Coin Sorter PLN                  */
/* (No longer on Thingiverse)                       */
/* by Seveneq                                       */
/* https://www.thingiverse.com/Seveneq              */
/*                                                  */
/* Improved Auto Coin Sorter V4.1, V4, V3, V2, V1   */
/* https://www.thingiverse.com/thing:3203049        */
/* by Bikecyclist                                   */
/* https://www.thingiverse.com/Bikecyclist          */
/*                                                  */
/* Sorteador Monedas Mexicanas                      */
/* https://www.thingiverse.com/thing:3204506        */
/* by morenot3131                                   */
/* https://www.thingiverse.com/morenot3131          */
/*                                                  */
/* Coin sorter for UK coins (inc new Â£1)            */
/* https://www.thingiverse.com/thing:2498200        */
/* by mabbog                                        */
/* https://www.thingiverse.com/mabbog               */
/*                                                  */
/* Auto Coin Sorter for All Currencies              */
/* https://www.thingiverse.com/thing:499177         */
/* by Youngcat                                      */
/* https://www.thingiverse.com/youngcat             */
/*                                                  */
/* Customized versions of Youngcat's Coin Sorter    */
/* for the following currencies:                    */
/*                                                  */
// ARS
// https://www.thingiverse.com/thing:1955336
// by
// https://www.thingiverse.com/charly3darg
//
// AUD
// https://www.thingiverse.com/thing:1073586
// by
// https://www.thingiverse.com/Sadiablo
//
// BRL
// https://www.thingiverse.com/thing:958842
// by
// https://www.thingiverse.com/igcefa
//
// CLP
// https://www.thingiverse.com/thing:1869330
// by
// https://www.thingiverse.com/yutroc
//
// CZK
// https://www.thingiverse.com/thing:1616408
// by
// https://www.thingiverse.com/TomasHalbych
//
// DKK
// https://www.thingiverse.com/thing:1032447
// by
// https://www.thingiverse.com/Nonbeliever
//
// HKD
// https://www.thingiverse.com/thing:1681392
// by
// https://www.thingiverse.com/g2david
//
// HUF
// https://www.thingiverse.com/thing:1025395
// by
// https://www.thingiverse.com/thebence98
//
// IDR
// https://www.thingiverse.com/thing:2166484
// by
// https://www.thingiverse.com/rizkypratama
//
// INR
// https://www.thingiverse.com/thing:2034732
// by
// https://www.thingiverse.com/Neeraja
//
// JPY
// https://www.thingiverse.com/thing:1717615
// by
// https://www.thingiverse.com/miettal
//
// KRW
// https://www.thingiverse.com/thing:3557926
// by
// https://www.thingiverse.com/alien9519
//
// MKD
// https://www.thingiverse.com/thing:3552088
// by
// https://www.thingiverse.com/Karevski
//
// MYR
// https://www.thingiverse.com/make:643395
// by
// https://www.thingiverse.com/wmfhadi
//
// NIS
// https://www.thingiverse.com/thing:2152362
// by
// https://www.thingiverse.com/EshRobotics
//
// NOK
// https://www.thingiverse.com/thing:1024392
// by
// https://www.thingiverse.com/RolBerg
//
// RON
// https://www.thingiverse.com/thing:2109232
// by
// https://www.thingiverse.com/szilveszter
//
// TWD
// https://www.thingiverse.com/thing:1671027
// by
// https://www.thingiverse.com/osmiumtpe
//
// XPF
// https://www.thingiverse.com/thing:1821933
// by
// https://www.thingiverse.com/M2orea

/* [General] */

// Choose a currency you use.
currency = 1; // [-1:Custom - Define Coins in Custom Currency Tab, 0:ARS - Argentine Peso, 1:AUD - Australian Dollar, 2:BRL - Brazilian Real, 3:CAD - Canadian dollar, 4:CHF - Swiss Franc, 5:CLP - Chilean Peso, 6:CZK - Czech Koruna, 7:DKK - Danish Krone, 8:EUR - Euro, 9:GBP - British Pounds, 10: HKD - Hong Kong Dollar, 11: HUF - Hungarian Forint, 12:IDR - Indonesian Rupiah, 13:INR Indian Rupee, 14: ISK - Icelandic Krona, 15:JPY - Japanese Yen, 32: KRW - South Korean Won, 31:MKD - Macedonian Denar, 16:MXN - Mexican Peso, 33: MYR - Malaysian Ringgit, 17: NIS - Israeli New Shekel, 18: NOK - Norwegian Krone, 30: NZD - New Zealand Dollar, 19:PEN - Peruvian Sol, 20:PLN - Polish Zloty, 21: RON - Rumanian Leu, 22:RUB - Russian Ruble, 23:SEK - Swedish Krona, 24:SGD - Singapore Dollar, 25:THB - Thai Baht, 26:TRY - Turkish Lira, 27:TWD - New Taiwan Dollar, 28:USD - US dollar, 34:UYU - Uruguayan Peso, 29:XFP - CFP Franc]

// Choose Coin Roll vs. Classic Slot Version
coin_roll_version = 1; // [1: Coin Roll Version, 2:Classic Slot Version]

// How much extra topboard length for placing the coins on the sorter? (In percent of the total topboard length.):
extra_topboard_length_percent = 14; // [0:30]

extra_topboard_length = extra_topboard_length_percent * 0.01;

// Style of vertical guard
guardstyle = "Frontandback";  // [Frontandback:Front and back guard rails, Frontguard: Front guard rail only]

// How much extra height on the right hand side of the guard rail? In millimeters:
extra_guard_height = 15; // [0:30]

// Topboard bottom rim height. (Holds topboard on.)
topboard_rim = 15; //[10:25]

// Offset value used for rounding tube rack corners (normally no need to change)
roundoffset = 1; // [0:2]

// Which parts would you like to see?
part = "allunassembled"; // [allassembled:All parts assembled, allunassembled:All parts unassembled, basebox:Base box only,topboard:Top board only, tuberack:Tube rack only, tubes:Tubes only]

/* [Custom Currency] */

// Enter ISO 4217 code for custom currency - see https://en.wikipedia.org/wiki/ISO4217#Activecodes
custom_currency_code = "ABC";

// Diameter of largest coin (0 to skip this coin)
coin01dia = 10.01;
// Thickness of largest coin
coin01th = 1.01;
// Number of coins in a coin tube (for this coin)
coin01n = 25;

// Diameter of 2nd largest coin (0 to skip this coin)
coin02dia = 9.01;
// Thickness of this coin
coin02th = 1.01;
// Number of coins in a coin tube (for this coin)
coin02n = 25;

// Diameter of 3rd largest coin (0 to skip this coin)
coin03dia = 8.01;
// Thickness of this coin
coin03th = 1.01;
// Number of coins in a coin tube (for this coin)
coin03n = 25;

// Diameter of 4th largest coin (0 to skip this coin)
coin04dia = 7.01;
// Thickness of this coin
coin04th = 1.01;
// Number of coins in a coin tube (for this coin)
coin04n = 50;

// Diameter of 5th largest coin (0 to skip this coin)
coin05dia = 0.00;
// Thickness of this coin
coin05th = 1.01;
// Number of coins in a coin tube (for this coin)
coin05n = 50;

// Diameter of 6th largest coin (0 to skip this coin)
coin06dia = 0.00;
// Thickness of this coin
coin06th = 1.01;
// Number of coins in a coin tube (for this coin)
coin06n = 50;

// Diameter of 7th largest coin (0 to skip this coin)
coin07dia = 0.00;
// Thickness of this coin
coin07th = 1.01;
// Number of coins in a coin tube (for this coin)
coin07n = 50;

// Diameter of 8th largest coin (0 to skip this coin)
coin08dia = 0.00;
// Thickness of this coin
coin08th = 1.01;
// Number of coins in a coin tube (for this coin)
coin08n = 50;

// Diameter of 9th largest coin (0 to skip this coin)
coin09dia = 0.00;
// Thickness of this coin
coin09th = 1.01;
// Number of coins in a coin tube (for this coin)
coin09n = 50;

// Diameter of 10th largest coin (0 to skip this coin)
coin10dia = 0.00;
// Thickness of this coin
coin10th = 1.01;
// Number of coins in a coin tube (for this coin)
coin10n = 50;

/* [Hidden] */

allcoins = [
	["ARS",
		[26.00, 25.00, 24.00, 19.00],
		[ 2.15,  2.00,  1.75,  1.35],
		[   25,    25,    50,    50],
	],

	// Source: Wikipedia
	["AUD",
		[ 31.65, 28.65, 25.00, 23.60, 20.50, 19.41],
		[  2.80,  2.50,  3.00,  2.00,  2.80,  1.30],
		[    25,    25,    25,    50,    25,    50],
	],

	["BRL",
		[  27,     25,  23.50,    23,    22,    22,    21,    20],
		[ 1.95,  2.25,   1.40,  2.85,  1.65,  1.20,  1.20,  2.23],
		[   25,    25,     50,    25,    50,    50,    50,    50],
	],

	["CAD",
		[28.00, 27.13, 26.50, 23.88, 21.20, 19.05, 18.03],
		[ 1.80,  1.95,  1.75,  1.58,  1.76,  1.45,  1.22],
		[   25,    25,    50,    50,    50,    50,    50],
	],

	["CHF",
		[31.45, 27.40, 23.20, 21.05, 19.15, 18.20, 17.15],
		[ 2.35,  2.15,  1.15,  1.65,  1.45,  1.25,  1.25],
		[   25,    25,    50,    50,    50,    50,    50],
	],

	["CLP",
		[ 26.94, 25.52,  23.5,  21.08],
		[  2.00,  2.00,  2.33,   1.46],
		[    25,    25,    25,     50],
	],

	["CZK",
		[ 27.50,    26,  24.5,    23,  21.5,    20],
		[  2.55,  2.55,  2.55,  1.85,  1.85,  1.85],
		[    25,    25,    25,    50,    50,    50],
	],

	["DKK",
		[ 28.5,  27.00,  24.5,  23.35,  21.5,  20.25],
		[  2.0,   2.35,   1.8,    2.3,  1.55,    1.6],
		[   25,     25,    50,     25,    50,     50],
	],

	["EUR",
		//2.00   0.50   1.00   0.20   0.05   0.10   0.02   0.01
		[25.75, 24.25, 23.25, 22.25, 21.25, 19.75, 18.75, 16.25],
		[ 2.20,  2.38,  2.33,  2.14,  1.67,  1.93,  1.67,  1.67],
		[   25,    20,    25,    40,    50,    40,    50,    50],
	],

	["GBP",
		[28.5,	27.5, 25.9, 24.5, 23.5, 21.4, 20.3, 18.0],
		[2.5, 1.78, 2.03, 1.85, 3.15,  1.7, 1.65, 1.70],
		[ 25,   25,   25,   50,   25,   50,   50,   50],
	],

	["HKD",
		[   28, 27.00,  25.5,  24,  22.50,    19,  17.5],
		[ 2.03,  3.26,  1.95,   3,   1.72,  1.52,  1.15],
		[   25,    25,    25,  25,     50,    50,    50],
	],

	["HUF",
		[ 28.3,  27.4,  26.3,  24.8,  23.8,  21.2],
		[    2,   1.7,   1.9,   1.3,   2.2,   1.3],
		[   25,    50,    50,    50,    50,    50],
	],

	["IDR",
		[ 27.2,  25,   24,   23],
		[  2.3, 2.1,  1.5,  1.9],
		[   25,  25,   50,   50],
	],

	["INR",
		[  28,   25,   23,   22],
		[ 1.8,  1.4,  2.5,  1.3],
		[   25,  25,   25,   50],
	],

	// Source: Wikipedia
	["ISK",
		//  10    100      5     50      1
		[27.50, 25.50, 24.50, 23.00, 21.50],
		[ 1.78,  2.25,  1.75,  2.60,  1.66],
		[   25,    25,    25,    25,    50],
	],

	["JPY",
		[26.5,  23.5,  22.6,  22.0,  21.0,  20.0],
		[ 1.8,   1.5,   1.7,   1.5,   1.7,   1.5],
		[   25,   50,    50,    50,    50,    50],
	],

	["MXN",
		[  32,     28,  25.5,    23,   21,   17],
		[ 2.15,  2.00,  1.75,  1.95,  1.8,  1.7],
		[   25,    25,    50,    50,   50,   50],
	],

	["NIS",
		[  26,   24,   23,   22,  21.6,   18],
		[ 1.6,  2.4,  2.2,  1.5,   2.3,  2.1],
		[  25,   25,   25,   50,    25,   50],
	],

	["NOK",
		[ 27.5,  26,  24,  21],
		[  2.2,   2,   2, 1.7],
		[  25,   25,  25,  50],
	],

	["PEN",
		[25.50, 24.38, 23.00, 22.30, 22.00, 20.50, 18.00],
		[ 1.65,  2.13,  1.26,  2.07,  1.65,  1.26,  1.26],
		[   25,    25,    50,    50,    50,    50,    50],
	],

	["PLN",
		[24.00, 23.00, 21.50, 20.50, 19.50, 18.50, 17.50, 16.50, 15.50],
		[ 2.00,  1.70,  2.00,  1.70,  1.40,  1.70,  1.40,  1.70,  1.40],
		[   25,    25,    25,    50,    50,    50,    50,    50,    50],
	],

	["RON",
		[ 23.7,  20.35,  18.13,  16.75],
		[ 1.82,   1.75,    1.6,   1.57],
		[   25,     25,     25,     50],
	],

	["RUB",
		[25.08, 23.17, 22.10, 20.56, 19.47, 17.55],
		[ 1.90,  1.84,  2.25,  1.40,  1.45,  1.23],
		[   25,    25,    25,    50,    50,    50],
	],

	["SEK",
		[23.75, 22.50, 20.50, 19.50],
		[ 1.97,  1.79,  1.79,  2.90],
		[   25,    25,    25,    25],
	],

	// Source: Wikipedia
	["SGD",
		//1.00   0.50   0.20   0.10   0.05
		[24.65, 23.00, 21.00, 18.50, 16.75],
		[ 2.50,  2.45,  1.72,  1.38,  1.22],
		[   25,    25,    50,    50,    50],
	],

	["THB",
		[26.00, 24.05, 22.05, 20.01],
		[ 2.16,  2.13,  1.48,  1.38],
		[   20,    20,    50,    50],
	],

	// Source: Wikipedia
	["TRY",
		//1.00   0.50   0.25   0.10   0.05   0.01
		[26.15, 23.85, 20.50, 18.50, 17.50, 16.50],
		[ 1.90,  1.90,  1.65,  1.65,  1.65,  1.35],
		[   25,    25,    50,    50,    50,    50],
	],

	["TWD",
		[ 28,    26,   22 ,  20],
		[ 2.4,  1.9,  1.6,  1.6],
		[  25,   25,   50,   50],
	],

	["USD",
		//0.50   1.00   0.25   0.05   0.01   0.10
		[30.61, 26.50, 24.26, 21.21, 19.05, 17.91],
		[ 2.15,  2.00,  1.75,  1.95,  1.55,  1.35],
		[   20,    25,    40,    40,    50,    50],
	],

	["XFP",
		[   33,    31,  29.89,  28.48,  27.02,  23.95,    23],
		[ 2.37,  2.24,   1.98,   2.14,   1.76,   1.84,  1.43],
		[   25,    25,     25,     25,     50,     50,    50],
	],

	// Source: Wikipedia
	["NZD",
		// 200     50    100     20     10
		[26.50, 24.75, 23.00, 21.75, 20.50],
		[ 2.70,  1.70,  2.74,  1.56,  1.58],
		[   25,    25,    25,    50,    50],
	],

	["MKD",
		[27.50, 26.70, 25.50, 24.58, 23.90],
		[ 1.80,  1.90,  1.80,  2.07,  1.78],
		[   25,    25,    25,    25,    50],
	],

	["KRW",
		[27.00, 24.50, 22.00, 18.50],
		[ 1.92,  1.75,  1.60,  1.60],
		[   25,    25,    50,    50],
	],

	["MYR",
		[27.76, 23.59, 22.65, 20.60, 19.40, 18.80,  17.78],
		[ 2.18,  1.75,  1.92,  1.75,  1.37,  1.50,   1.30],
		[   25,    25,    25,    50,    50,    50,     50],
	],

	["UYU",
		[ 28, 26, 23, 20],
		[  3,  2,  2,  2],
		[ 25, 25, 50, 50],
	]
];

sqrt2 = sqrt(2);

echo (allcoins[currency]);

//
// Hidden Obsolescent Parameters
//

// Choose a pattern for the back side.
pattern = "no"; // [no:Solid with contoured back, chncoin:Chinese ancient coin pattern, mesh:Mesh pattern]

// If a back side pattern is selected, should it be filled in?
pattern_fill = "yes"; // [yes:filled - in back, no:open back]

// Choose the desired mesh thickness. In millimeters:
mesh_thickness = 0.8;

//
// MAIN
//
// TODO:
height = 100;

othercoinsdt =
[
	[coin01dia, coin01th, coin01n],
	[coin02dia, coin02th, coin02n],
	[coin03dia, coin03th, coin03n],
	[coin04dia, coin04th, coin04n],
	[coin05dia, coin05th, coin05n],
	[coin06dia, coin06th, coin06n],
	[coin07dia, coin07th, coin07n],
	[coin08dia, coin08th, coin08n],
	[coin09dia, coin09th, coin09n],
	[coin10dia, coin10th, coin10n]
];

coins = currency >= 0 ?
	[
		allcoins[currency][1],
		allcoins[currency][2],
		allcoins[currency][3]
	] : [
		[for (i = othercoinsdt) if(i[0] > 0) i[0]],
		[for (i = othercoinsdt) if(i[0] > 0) i[1]],
		[for (i = othercoinsdt) if(i[0] > 0) i[2]]
	];

echo(coins);

coin_diams = coins[0];
coin_thicknesses = coins[1];
coin_numbers = coins[2];

enable_box = (part == "allassembled" || part == "allunassembled" || part == "basebox");
enable_mesh = (pattern != "no" && pattern != "slim");
enable_topboard = (part == "allassembled" || part == "allunassembled" || part == "topboard");
enable_tube = (part == "allassembled" || part == "allunassembled" || part == "tubes") && (coin_roll_version == 1);
enable_tube_rack = (part == "allassembled" || part == "allunassembled" || part == "tuberack");
enable_tube_rack_scale = true;
assembled = (part != "allunassembled");
layflat = (part != "allassembled" && part != "allunassembled");

// Thickness of back - side fill - in (if selected)
minwallthickness = 0.3;

// Thickness of tube walls
thtubewall = 0.5;

// Tolerance between tubes and tuberack
toltuberack = 0.25;

guardcornerradius = 5;

sorterminheight = height;
boardthickness = 2.0; // This also implies wall thickness
boardleftpadding = 1;
boardrightpadding = 1;
boardprimaryslope = 16;
boardsecondaryslope = 15;
horizontalguardwidth = 3;
coinpadding = 0.4;
coinpaddingtopboard = 0.25;
nozzlesize = 0.4;
nozzlesizeupbound = 0.41;

tuberackshorter = 5;
tuberackfrontbackcut = 2;
tuberackbasethickness = 4.0;
tuberackbackthinner = 1;
tuberackscaledepth = 0.4;
tuberackscaleheight = 0.8;
tuberackpadding = 0.5; // Applies to tuberack retaining ledge horizontally and vertically
tuberackretainingledgeheight = tuberackbasethickness - tuberackpadding;

unassembledtopboardlift = 45;
unassembledtuberacklift = 20;
unassembledtubeslift = 40;

topboardbigger = 1.6;

$fa = 6;  // default: 12
$fs = 1;  // default: 2

coincount = len(coin_diams);
coinmaxindex = coincount - 1;

boardlength = (boardleftpadding + boardrightpadding
								+ sumcoinsd()
								+ coinpadding * coincount * 2
								+ boardthickness * (coincount + 3));

boardwidth = coin_diams[0] + coinpadding + boardthickness * 3;

slopeheight = tan(boardsecondaryslope) * boardwidth + tan(boardprimaryslope) * boardlength;

sortermaxheight = sorterminheight + slopeheight + boardthickness;
echo("box length:", boardlength);
//echo("boardwidth:", boardwidth);
echo("box min height:", sorterminheight);
echo("box max height:", sortermaxheight);

//projection (cut = true)
translate ([0, 0, -80])
main();

module main() {
	topboardlift = assembled ? 0 : unassembledtopboardlift;
	tuberacklift = assembled ? 0 : unassembledtuberacklift;
	tubeslift = assembled ? 0 : unassembledtubeslift;
	if (layflat) mainimplflat(topboardlift, tuberacklift, tubeslift);
	else mainimpl(topboardlift, tuberacklift, tubeslift);
}

module mainimpl(topboardlift = 0, tuberacklift = 0, tubeslift = 0) {
	if (enable_box) basebox();
	if (enable_topboard) translate([0, 0, topboardlift]) topboard();
	if (enable_tube_rack) translate([0, 0, tuberacklift]) tuberack();
	if (enable_tube) translate([0, 0, tubeslift]) tubes();
}

module mainimplflat(topboardlift = 0, tuberacklift = 0, tubeslift = 0) {
	if (enable_box) {
		if (enable_mesh) rotate([-90, 0, 0]) basebox();
		else basebox();
	}
	if (enable_topboard) {
		translate([0, 0, topboardlift])
		untransformtopboard(sorterminheight)
		topboard();
	}
	if (enable_tube_rack) translate([0, 0, tuberacklift]) tuberack();
	if (enable_tube) translate([0, 0, tubeslift]) tubes();
}

//
// BASE BOX
//

// Component: the box.
module basebox() {
	render(convexity = 4) {
		difference() {
			union() boxempty();
			if (enable_mesh) boardbackhollow(boardthickness * 1.5);
		}
	}

	if (enable_mesh) {
		intersection() {
			boardbackmesh();
			union() {
				boardbackhollow();
				boxbackfill();
			}
		}
		// Closed backside
		if (pattern_fill == "yes") {
			translate([0, boxsize()[1], 0]) {
				rotate([-90, 0, 0]) {
					linear_extrude(minwallthickness, convexity = 2) {
						projection(cut = false) {
							rotate([90, 0, 0]) boxempty();
						}
					}
				}
			}
		}
	} else boxbackfill();
}

function boxsize(fatter = 0, thicker = 0, altitude = 0, fronter = 0, taller = 0) = [boardlength + fatter * 2 + thicker * 2, boardwidth + fatter * 2 + thicker * 2 + fronter, sortermaxheight + fatter * 2 + thicker * 2 + taller];

module boxmove(fatter = 0, thicker = 0, altitude = 0, fronter = 0, taller = 0) {
	translate([-fatter - thicker, -fatter - thicker - fronter, altitude - fatter - thicker]) {
		children();
	}
}

module boxempty() {
	size = boxsize();
	cuttopside() {
		difference () {
			boxemptytall();

			translate([4 * boardthickness, boardthickness + 0.01, boardthickness]) {
				cube([size[0] - 8 * boardthickness - boardleftpadding - boardrightpadding, size[1], size[2]]);
			}
		}

		difference (){
			translate([0, -boardthickness, 0])
			cube([size[0], boardthickness + tuberackfrontcuty(), tuberackretainingledgeheight]);

			linear_extrude(height = tuberackretainingledgeheight + 0.01, center = false, convexity = 2)
			offset(tuberackpadding)
			tuberackbase2();
		}
	}
}

module boxemptytall(fatter = 0, thicker = 0, altitude = 0) {
	difference() {
		boxoutersolidtall(fatter, thicker, altitude);
		boxinnersolidtall(fatter, thicker, altitude);
	}
}

module boxoutersolidtall(fatter = 0, thicker = 0, altitude = 0, fronter = 0, taller = 0) {
	boxmove(fatter, thicker, altitude, fronter, taller) {
		cube(boxsize(fatter, thicker, altitude, fronter, taller));
	}
}

module boxinnersolidtall(fatter = 0, thicker = 0, altitude = 0) {
	boxoutersolidtall(
		fatter - boardthickness - thicker, thicker, altitude,
		boardthickness + thicker + 0.1,
		boardthickness + thicker + 0.1
	);
}

module boardbackhollow(thicker = 0) {
	xyz = boxsize(fatter = -boardthickness - thicker);
	cuttopside(altitude = -thicker)
	boxmove(fatter = -boardthickness - thicker)
	translate([0, xyz[1] + thicker/2, 0]) {
		cube([xyz[0], boardthickness + thicker, xyz[2]]);
	}
}

module boxbackfill(thicker = 0) {
	cuttopside(altitude = -thicker) {
		boxbackfilltall();
	}
}

module boxbackfilltall(wallonly = true) {
	linear_extrude(height = sortermaxheight, center = false, convexity = 8) {
		translate([0, coinpadding * 2]) {
			if (wallonly) {
				intersection() {
					offset(boardthickness) {
						difference() {
							square([boxsize()[0], boxsize()[1] - boardthickness - coinpadding * 2 - 0.01]);

							tuberackbackcontour();
						}
					}

					tuberackbackcontour();
				}
			} else tuberackbackcontour();
		}
	}
}

module tuberackbackcontour() {
	difference() {
		polygon(tuberackcutbackcomplete());
		for (i = [0 : coinmaxindex]) coinholeplain(i);
	}
}

// Transformation: cut the right, left, back and front side.
module cutsides(fatter = 0, thicker = 0) {
	intersection() {
		union() children();
		boxoutersolidtall(fatter, thicker, taller = sortermaxheight);
	}
}

module cuttopside(fatter = 0, thicker = 0, altitude = 0) {
	difference() {
		union() children();
		topside(sorterminheight + fatter + altitude);
	}
}

//
// MESH
//

module boardbackmesh() {
	diaglen = sqrt(boardlength * boardlength + sortermaxheight * sortermaxheight);

	if (pattern == "mesh") {
		boardbackmeshgrids(
			mesh_thickness, 15, ceil(diaglen / 15) + 1, 45,
			[boardlength / 2, boardwidth * 0.7, sortermaxheight / 2],
			"y", boardwidth
		);
	} else if (pattern == "chncoin") {
		boardbackmeshancientcoins(
			mesh_thickness, 18, ceil(diaglen / 18 / 2) + 2,
			[boardlength / 2, boardwidth * 0.7, sortermaxheight / 2],
			"y", boardwidth
		);
	}
}

module meshextrude(center = [0, 0, 0], normaldirection = "z", height = 10, convexity = 10) {
	translate(center) {
		rotate(normaldirection == "x" ? [0, 90, 0] : normaldirection == "y" ? [-90, 0, 0] : [0, 0, 0]) {
			linear_extrude(height, center = true, convexity = convexity) {
				children();
			}
		}
	}
}

module boardbackmeshgrids(thickness, gap, count, rotateangle = 0, center = [0, 0, 0], normaldirection = "z", height = 10) {
	length = (thickness + gap) * (count - 1) + thickness;
	meshextrude(center, normaldirection, height, convexity = 8)
	rotate([0, 0, rotateangle])
	translate([-length / 2, -length / 2]) {
		for (i = [0 : count - 1]) {
			translate([(thickness + gap) * i, 0]) {
				square([thickness, length]);
			}
			translate([0, (thickness + gap) * i]) {
				square([length, thickness]);
			}
		}
	}
}

module boardbackmeshancientcoins(thickness, radius, count, center = [0, 0, 0], normaldirection = "z", height = 10) {
	meshextrude(center, normaldirection, height, convexity = 8) {
		translate([-sqrt2 * radius * (count - 1) / 2, -sqrt2 * radius * (count - 1) / 2]) {
			for (i = [0 : count - 1]) {
				for (j = [0 : count - 1]) {
					translate([sqrt2 * radius * i, sqrt2 * radius * j]) {
						render(convexity = 2) {
							difference() {
								circle(r = radius + thickness / 2);
								circle(r = radius - thickness / 2);
							}
						}
					}
				}
			}
		}
	}
}

//
// TOP BOARD
//

// Component: the solid board on top (topboard)
module topboard() {
	difference() {
		// the board itself
		union() {
			cutsides() {
				transformtopboard(sorterminheight) {
					cube([boardlength * 2, boardwidth * 2, boardthickness]);
				}
			}

			difference () {
				transformtopboard(sorterminheight) {
					translate([0, 0, -topboard_rim
				 + boardthickness - 0.01]) {
						linear_extrude(topboard_rim
					) {
							offset(topboard_rim
						/2) {
								scale([1.05 + extra_topboard_length, 1.05, 1]) {
									projection(cut = false) {
										cutsides() {
											transformtopboard(sorterminheight) {
												cube([boardlength * 2, boardwidth * 2, boardthickness]);
											}
										}
									}
								}
							}
						}
					}
				}

				cutsides() {
					transformtopboard(sorterminheight) {
						cube([boardlength * 2, boardwidth * 2, boardthickness]);
					}
				}

				topboardbottomcutout();
			}
		}

		// holes and cuts
		for (i = [0 : coinmaxindex]) {
			coinhole(i, biggerr = coinpaddingtopboard - coinpadding);
			slopecutforcoin(i, biggerr = coinpaddingtopboard - coinpadding);
		}
	}

	difference() {
		union() {
			verticalguard();

			if (guardstyle == "Frontandback") {
				translate([0, boardwidth, boardwidth * sin (boardsecondaryslope)]) {
					verticalguard();
				}
			}
		}

		topboardbottomcutout();
	}

	horizontalguard();
}

// Negative component: Basebox - sized hole in topboard bottom
module topboardbottomcutout() {
	size = boxsize();
	translate ([-topboardbigger / 2, -topboardbigger / 2, 0.01]) {
		resize ([size[0] + topboardbigger, size[1] + topboardbigger, size[2]]) {
			hull() basebox();
		}
	}
}

// Component: the guard on top of the top board.
module verticalguard() {
	intersection() {
		translate([0, 0, -2 * guardcornerradius]) {
			rotate([-90, 0, 0]) {
				linear_extrude(boardthickness) {
					offset(guardcornerradius) {
						offset(-guardcornerradius) {
							projection(cut = false) {
								rotate([90, 0, 0]) {
									difference() {
										intersection() {
											cube([boardlength * (1 + extra_topboard_length), boardthickness, sortermaxheight * 2]);

											topside(sorterminheight + boardthickness - 0.1);
										}

										translate([0, 0, 10]) topverticalguard(sorterminheight + boardthickness * 2, extra_guard_height);
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

// Component: the guard crossing the holes.
module horizontalguard() {
	// should be similar to topboard()
	cutsides() {
		transformtopboard(sorterminheight) {
			cube([boardlength * 2, horizontalguardwidth + boardthickness, boardthickness]);
		}
	}
}

// Submodule: the upper solid box that is rotated the same as the top board.
module topside(altitude = 0) {
	// rotate it and raise it
	transformtopboard(altitude) {
		// a big box
		translate([-boardlength / 2, -boardwidth / 5, 0]) {
			cube([boardlength * 2, boardwidth * 2, sortermaxheight]);
		}
	}
}

// Submodule: the vertical guard cutter that is rotated the same as the top board.
module topverticalguard(altitude = 0, righthandaltitude = 0) {
	// rotate it and raise it
	transformtopboard(altitude) {
		// a big box
		translate([0, -boardwidth / 5, 0]) {
			hull() {
				cube([0.01, boardwidth * 2, sortermaxheight]);

				translate([0.8 * boardlength, 0, 0])
				cube([0.01, boardwidth * 2, sortermaxheight]);
			}
			hull() {
				translate([0.8 * boardlength, 0, 0])
				cube([0.01, boardwidth * 2, sortermaxheight]);

				translate([2 * (1 + extra_topboard_length) * boardlength, 0, 2 * righthandaltitude])
				cube([0.01, boardwidth * 2, sortermaxheight]);
			}
		}
	}
}

// Transformation: do the rotation.
module transformtopboard(liftz = 0) {
	translate([0, 0, liftz]) {
		rotate(a = boardsecondaryslope, v = [1, 0, tan(boardprimaryslope)]) {
			rotate([0, -boardprimaryslope, 0]) children();
		}
	}
}

module untransformtopboard(liftz = 0) {
	rotate([0, boardprimaryslope, 0]) {
		rotate(a = -boardsecondaryslope, v = [1, 0, tan(boardprimaryslope)]) {
			translate([0, 0, -liftz]) children();
		}
	}
}

//
// COIN CUT
//

// Submodule: the coin holes.
module coinhole(n, biggerr = 0) {
	translate([coincenterx(n), coincentery(n), boardthickness + 0.1]) {
		cylinder(h = sortermaxheight, r = coin_diams[n] / 2 + coinpadding + biggerr);
	}
}

// Submodule: the coin holes, in a plain.
module coinholeplain(n) {
	translate([coincenterx(n), coincentery(n)]) {
		circle(coin_diams[n] / 2 + coinpadding);
	}
}

// Submodule: the solid tube, in a plain.
module coinholeplainthicker(n) {
	translate([coincenterx(n), coincentery(n)]) {
		circle(coin_diams[n] / 2 + coinpadding + boardthickness);
	}
}

// Submodule: the slope cuts.
module slopecutforcoin(n, biggerr = 0) {
	render(convexity = 2) {
		intersection() {
			// the (too big) actual slope cut
			transformtopboard(sorterminheight) {
				a = boardprimaryslope;
				th = boardthickness;
				cutlength = coin_diams[n] * 1.5;
				movex = coinleftx(n + 1) - cutlength;
				cutlengthrotated = cutlength / cos(a);
				movexrotated = movex / cos(a) + th * tan(a) + 1;

				translate([movexrotated, 0, 0]) {  // move rightwards
					// make a triangle - box
					rotate([0, -atan(th / cutlengthrotated), 0]) {
						cube([cutlengthrotated * 2, boardwidth, th * 2]);
					}
				}  // translate, move rightwards
			}  // transformtopboard

			// limiting box
			translate([coincenterx(n), 1, 0]) {
				cube([coin_diams[0], cointopy(n) - 1 + biggerr, sortermaxheight]);
			}
		}
	}
}

//
// COIN TUBE RACK
//

// Component: the tuberack.
module tuberack() {
	linear_extrude(height = tuberackbasethickness + 0.01, center = false, convexity = 2) {
		tuberackbase2();
	}

	difference() {
		translate([0, 0, tuberackbasethickness])
		tuberackbody3();

		if (enable_tube_rack_scale) {
			translate([0, 0, tuberackbasethickness + 1.5]) { // +1.5 compensates for tube bottom thickness
				tuberackscales();
			}
		}

		translate([0, -1, sorterminheight - tuberackshorter]) {
			rotate([0, -boardprimaryslope, 0]) {
				cube([boardlength * 2, boardwidth * 2, sortermaxheight]);
			}
		}
	}
}

// Submodule: the "last coins" and the tube connecting part.
module tuberackbase2() {
	offset(roundoffset) offset(-roundoffset) {
		polygon(
			concat(
				[
					[tuberackcutxx(0)[0], tuberackfrontcuty()],
					[tuberackleftx(), tuberackfronty()],
					[tuberackleftx() + tuberackbackthinner, tuberackbacky()]
				],
				tuberackcutbackxys(),
				[
					[tuberackrightx() - tuberackbackthinner, tuberackbacky()],
					[tuberackrightx(), tuberackfronty()],
					[tuberackcutxx(coinmaxindex)[1], tuberackfrontcuty()]
				]
			)
		);
	}
}

// Submodule: the tube connecting part subtracted by coin holes.
module tuberackbase3() {
	difference() {
		tuberackbase2();
		for (i = [0 : coinmaxindex]) {
			if (coin_roll_version == 1) {
				offset (thtubewall + toltuberack) coinholeplain(i);
			} else coinholeplain(i);
		}
	}
}

module tuberackbody3() {
	linear_extrude(height = sortermaxheight, center = false, convexity = 2) tuberackbase3();
}

module tuberackscales() {
	for (i = [0 : coinmaxindex]) {
		render(convexity = 2) {
			interval = (coin_thicknesses[i] > 1.5 ? 1 : 2);
			for (j = [interval : interval : sortermaxheight/coin_thicknesses[i]]) {
				translate([coincenterx(i), tuberackfrontcuty() - 1, j * coin_thicknesses[i] - tuberackscaleheight / 2]) {
					lengthoffset = (j % 10 == 0 ? 3 : j % 2 == 0 ? 1 : -0.5);
					cube([tuberackcuthalfwidth(i) + lengthoffset, tuberackscaledepth + 1, tuberackscaleheight]);
				}
			}
		}
	}
}

//
// COIN TUBES
//

// Component: the tubes
module tubes() {
	translate([0, 0, tuberackbasethickness]) {
		for (i = [0 : coinmaxindex]) {
			color("green") {
				cointube (i);
			}
		}
	}
}

// Submodule: the coin tube
module cointube(n) {
	translate([coincenterx(n), coincentery(n)]) {
		difference() {
			makecointube(coin_diams[n] + 2 * coinpadding, coin_thicknesses[n], coin_numbers[n]);

			translate([0, 0, -0.01]) {
				ndie(n + 1, 0.8 * (coin_diams[n] / 2 - 2) / sqrt2);
			}
		}
	}
}

cylinders = [[0], [5], [1, 9], [1, 5, 9], [1, 3, 7, 9], [1, 3, 5, 7, 9], [1, 3, 4, 6, 7, 9], [1, 3, 4, 5, 6, 7, 9], [1, 2, 3, 4, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9]];

dots = [[0, 0], [-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];

module ndie(n, r) {
	if (n > 0 && n < 10) {
		for (i = cylinders [n]) {
			translate(r * dots [i]) {
				cylinder(d = 2, h = 1);
			}
		}
	} else if (n == 10) {
		for (i = [1, -1]) {
			translate([i * r / sqrt2, i * r / sqrt2]) {
				ndie(5, r / 2);
			}
		}
	}
}

module makecointube (dcoin, hcoin, ncoins) {
	translate([0, 0, 1]) {
		difference() {
			hull() {
				translate([0, 0, -1]) {
					cylinder(d = dcoin, h = 0.5 + (ncoins + 0.5) * hcoin);

					cylinder(d = 2 * thtubewall + dcoin, h = 0.5 + (ncoins + 0.5) * hcoin);
				}
			}

			translate([0, 0, 0.5]) {
				cylinder(d = dcoin, h = 0.5 + (ncoins + 0.5) * hcoin + 0.01);
			}
		}
	}
}


//
// FUNCTIONS
//

// Accumulated coins' diameters.
function sumcoinsd(firstn = coincount) = firstn <= 0 ? 0 : coin_diams[firstn - 1] + sumcoinsd(firstn - 1);

// Coin positions.
function coincenterx(n) = coinleftx(n) + coin_diams[n] / 2;

function coinleftx(n) = boardleftpadding + sumcoinsd(n) + coinpadding * (2 * n + 1) + boardthickness * (n + 2);

function coincentery(n) = coin_diams[n] / 2 + coinpadding + boardthickness;

function cointopy(n) = coincentery(n) + coin_diams[n] / 2 + coinpadding;

function coinbottomy(n) = coincentery(n) - coin_diams[n] / 2 - coinpadding;

// Tube cuts.
function tuberackleftx() = boardthickness + coinpadding;
function tuberackrightx() = boardlength - boardthickness - coinpadding;
function tuberackfronty() = coinpadding;
function tuberackbacky() = boardwidth - boardthickness - coinpadding;
function tuberackfrontcuty() = coinbottomy(0) + tuberackfrontbackcut;

function tuberackcuthalfwidth(n) = sqrt(pow(coin_diams[n] / 2 + coinpadding + boardthickness, 2) - pow(coin_diams[n] / 2 + coinpadding - tuberackfrontbackcut, 2));

function tuberackcutxx(n) =
	[
		coincenterx(n) - tuberackcuthalfwidth(n),
		coincenterx(n) + tuberackcuthalfwidth(n)
	];

function tuberackcutbackxyxy(n) =
	[
		[
			coincenterx(n) - tuberackcuthalfwidth(n),
			cointopy(n) - tuberackfrontbackcut
		],
		[
			coincenterx(n) + tuberackcuthalfwidth(n),
			cointopy(n) - tuberackfrontbackcut
		]
	];

function tuberackcutbackxys(firstn = coincount) =
	firstn <= 0 ? [] :
	concat(tuberackcutbackxys(firstn - 1), tuberackcutbackxyxy(firstn - 1));

function tuberackcutbackcomplete() =
	concat([[tuberackleftx() + tuberackbackthinner, tuberackbacky()]],
		tuberackcutbackxys(),
		[[tuberackrightx() - tuberackbackthinner, tuberackbacky()]]
	);

// Tube connections.
function tuberackheightat(x) =
	sorterminheight - tuberackshorter - tuberackbasethickness + x * tan(boardprimaryslope);

function tuberackxheightat(x, zdelta = 0) = [x, tuberackheightat(x) + zdelta];

function tuberackconnectionheight(n) =
	sorterminheight - tuberackshorter - tuberackbasethickness + (
		n == 0 ? 0:
		coincenterx(n - 1) * tan(boardprimaryslope)
	);